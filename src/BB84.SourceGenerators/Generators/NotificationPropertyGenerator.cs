// Copyright: 2025 Robert Peter Meyer
// License: MIT
//
// This source code is licensed under the MIT license found in the
// LICENSE file in the root directory of this source tree.
using System.Globalization;
using System.Text;

using BB84.SourceGenerators.Attributes;
using BB84.SourceGenerators.Extensions;
using BB84.SourceGenerators.Generators.Base;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace BB84.SourceGenerators.Generators;

/// <summary>
/// Responsible for generating a notification property for fields marked
/// with the <see cref="GenerateNotificationAttribute"/> attribute.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class NotificationPropertyGenerator : AttributeBasedGenerator
{
	/// <summary>
	/// Initializes a new instance of the <see cref="NotificationPropertyGenerator"/> class.
	/// </summary>
	public NotificationPropertyGenerator() : base("GenerateNotification")
	{ }

	/// <inheritdoc/>
	protected override void Execute(SyntaxNode syntaxNode, SourceProductionContext context)
	{
		ClassDeclarationSyntax classDeclaration = (ClassDeclarationSyntax)syntaxNode;

		List<FieldDeclarationSyntax> members = [.. classDeclaration.Members
			.OfType<FieldDeclarationSyntax>()
			.Where(fieldDeclaration => fieldDeclaration is not null && fieldDeclaration.AttributeLists
				.Any(attributeList => attributeList.Attributes
					.Any(attribute => attribute.Name.ToString() == AttributeName)))];

		// fetch the field name and declaration type
		string className = classDeclaration.Identifier.Text;
		string classNamespace = classDeclaration.GetNamespace();

		StringBuilder sourceBuilder = new();
		sourceBuilder.AppendAutoGeneratedWarning();
		sourceBuilder.AppendLine();
		sourceBuilder.AppendLine("using System;");
		sourceBuilder.AppendLine("using System.ComponentModel;");
		sourceBuilder.AppendLine();
		sourceBuilder.AppendLine($"namespace {classNamespace}");
		sourceBuilder.AppendLine("{");
		sourceBuilder.AppendLine($"  public partial class {className} : INotifyPropertyChanged, INotifyPropertyChanging");
		sourceBuilder.AppendLine("  {");
		sourceBuilder.AppendLine("    /// <inheritdoc/>");
		sourceBuilder.AppendLine("    public event PropertyChangedEventHandler? PropertyChanged;");
		sourceBuilder.AppendLine();
		sourceBuilder.AppendLine("    /// <inheritdoc/>");
		sourceBuilder.AppendLine("    public event PropertyChangingEventHandler? PropertyChanging;");
		sourceBuilder.AppendLine();
		foreach (FieldDeclarationSyntax member in members)
		{
			foreach (VariableDeclaratorSyntax variable in member.Declaration.Variables)
			{
				string fieldName = variable.Identifier.Text;
				string fieldType = $"{member.Declaration.Type}";

				// Convert field name to property name (PascalCase)
				// Assuming the field name is in camelCase or snake_case, we convert it to PascalCase
				// For example: _myField becomes MyField
				// Note: This assumes the field name starts with an underscore, which is common for backing fields
				string propertyName = string.Empty;
				if (fieldName.StartsWith("_", StringComparison.OrdinalIgnoreCase))
					propertyName = fieldName[1..];
				propertyName = $"{char.ToUpper(propertyName[0], CultureInfo.InvariantCulture)}{propertyName[1..]}";

				// add the property fields
				sourceBuilder.AppendLine($"    public {fieldType} {propertyName}");
				sourceBuilder.AppendLine("    {");
				sourceBuilder.AppendLine($"        get => {fieldName};");
				sourceBuilder.AppendLine("        set");
				sourceBuilder.AppendLine("        {");
				sourceBuilder.AppendLine($"          if({fieldName} != value)");
				sourceBuilder.AppendLine("          {");
				sourceBuilder.AppendLine($"            RaisePropertyChanging(nameof({propertyName}));");
				sourceBuilder.AppendLine($"            {fieldName} = value;");
				sourceBuilder.AppendLine($"            RaisePropertyChanged(nameof({propertyName}));");
				sourceBuilder.AppendLine("          }");
				sourceBuilder.AppendLine("        }");
				sourceBuilder.AppendLine("    }");
				sourceBuilder.AppendLine();
			}
		}
		sourceBuilder.AppendLine("    protected void RaisePropertyChanging(string propertyName)");
		sourceBuilder.AppendLine("      => PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(propertyName));");
		sourceBuilder.AppendLine();
		sourceBuilder.AppendLine("    protected void RaisePropertyChanged(string propertyName)");
		sourceBuilder.AppendLine("      => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));");
		sourceBuilder.AppendLine("  }");
		sourceBuilder.AppendLine("}");
		sourceBuilder.AppendLine();

		string sourceText = sourceBuilder.ToString();
		context.AddSource($"{className}.g.cs", sourceText);
	}

	/// <inheritdoc/>
	protected override bool Predicate(SyntaxNode node)
	{
		bool result = node is ClassDeclarationSyntax classDeclaration
			&& classDeclaration.Members.Count > 0
			&& classDeclaration.Members.OfType<FieldDeclarationSyntax>().Any(fieldDeclaration
				=> fieldDeclaration is not null && fieldDeclaration.AttributeLists.Count > 0
				&& fieldDeclaration.AttributeLists.Any(attributeList
					=> attributeList.Attributes.Any(attribute
						=> attribute.Name.ToString() == AttributeName)));

		return result;
	}

	/// <inheritdoc/>
	protected override SyntaxNode Transform(GeneratorSyntaxContext context)
	{
		ClassDeclarationSyntax classDeclaration = (ClassDeclarationSyntax)context.Node;
		return classDeclaration;
	}
}
