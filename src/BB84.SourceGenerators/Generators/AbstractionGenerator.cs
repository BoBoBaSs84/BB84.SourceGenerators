using System.Text;

using BB84.SourceGenerators.Attributes;
using BB84.SourceGenerators.Extensions;
using BB84.SourceGenerators.Requests;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace BB84.SourceGenerators.Generators;

/// <summary>
/// Represents a source generator that generates abstractions for static classes.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class AbstractionGenerator : IIncrementalGenerator
{
	private const string GeneratorName = "BB84.SourceGenerators.Generators.AbstractionGenerator";
	private static readonly string GenerateAbstractionAttributeQualifiedName = typeof(GenerateAbstractionAttribute).FullName;

	/// <inheritdoc />
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		IncrementalValuesProvider<AbstractionRequest?> abstractionRequests =
				context.SyntaxProvider.CreateSyntaxProvider(
						predicate: static (node, _) => IsCandidateClassNode(node),
						transform: static (ctx, ct) => CreateAbstractionRequest(ctx, ct))
				.Where(static r => r is not null);

		context.RegisterSourceOutput(abstractionRequests, static (spc, request) =>
		{
			if (request is null)
				return;

			spc.AddSource($"{request.AbstractionType.Name}.g.cs", GenerateAbstractionSource(request));
			spc.AddSource($"{request.ImplementationType.Name}.g.cs", GenerateImplementationSource(request));
		});
	}

	/// <summary>
	/// Generates the source code for the abstraction interface based on the given request.
	/// </summary>
	/// <param name="request">
	/// The abstraction request containing information about the target type and generated abstraction.
	/// </param>
	/// <returns>
	/// The generated source code for the abstraction interface.
	/// </returns>
	private static string GenerateAbstractionSource(AbstractionRequest request)
	{
		IEnumerable<IMethodSymbol> methodSymbols = request.TargetType
			.GetMembers()
			.OfType<IMethodSymbol>()
			.Where(m => m.DeclaredAccessibility == Accessibility.Public && m.IsStatic && !request.ExcludeMethods.Contains(m.Name));

		string abstractionNamespace = GetFullNamespace(request.AbstractionType);

		StringBuilder sb = new();

		sb.AppendAutoGeneratedWarning(GeneratorName);
		sb.AppendLine($"namespace {abstractionNamespace}");
		sb.AppendLine("{");
		sb.AppendLine($"  public partial interface {request.AbstractionType.Name}");
		sb.AppendLine("  {");
		foreach (IMethodSymbol methodSymbol in methodSymbols)
		{
			sb.AppendLine($"    {CreateMethodComment(request, methodSymbol)}");
			sb.AppendLine($"    {CreateMethodSignature(methodSymbol)};");
		}
		sb.AppendLine("  }");
		sb.AppendLine("}");

		return sb.ToString();
	}

	private static string GenerateImplementationSource(AbstractionRequest request)
	{
		IEnumerable<IMethodSymbol> methodSymbols = request.TargetType
			.GetMembers()
			.OfType<IMethodSymbol>()
			.Where(m => m.DeclaredAccessibility == Accessibility.Public && m.IsStatic && !request.ExcludeMethods.Contains(m.Name));

		string abstractionNamespace = GetFullNamespace(request.AbstractionType);
		string implementationNamespace = GetFullNamespace(request.ImplementationType);

		StringBuilder sb = new();
		sb.AppendAutoGeneratedWarning(GeneratorName);
		if (abstractionNamespace != implementationNamespace)
		{
			sb.AppendLine($"using {abstractionNamespace};");
			sb.AppendLine();
		}
		sb.AppendLine($"namespace {implementationNamespace}");
		sb.AppendLine("{");
		sb.AppendLine($"  public partial class {request.ImplementationType.Name} : {request.AbstractionType.Name}");
		sb.AppendLine("  {");
		foreach (IMethodSymbol methodSymbol in methodSymbols)
		{
			sb.AppendLine($"    public {CreateMethodSignature(methodSymbol)}");
			sb.AppendLine($"      => {CreateMethodUsing(request, methodSymbol)};");
		}
		sb.AppendLine("  }");
		sb.AppendLine("}");
		return sb.ToString();
	}

	/// <summary>
	/// Creates a string representation of the specified method symbol, including its name and parameter list.
	/// </summary>
	/// <param name="request">The abstraction request containing the target type information.</param>
	/// <param name="methodSymbol">The method symbol to represent. Must not be <c>null</c>.</param>
	/// <returns>
	/// A string containing the method's name followed by its parameter names in parentheses, separated by commas.
	/// </returns>
	private static string CreateMethodUsing(AbstractionRequest request, IMethodSymbol methodSymbol)
	{
		IEnumerable<string> parameters = methodSymbol.Parameters.Select(p => p.Name);
		return $"{request.TargetType}.{methodSymbol.Name}({string.Join(", ", parameters)})";
	}

	/// <summary>
	/// Creates a string representation of a method signature, including its return type, name, and parameter list.
	/// </summary>
	/// <param name="methodSymbol">
	/// The symbol representing the method to generate the signature for. Must not be <c>null</c>.
	/// </param>
	/// <returns>
	/// A string containing the method's signature in the format: "ReturnType MethodName(Type1 param1, Type2 param2, ...);".
	/// </returns>
	private static string CreateMethodSignature(IMethodSymbol methodSymbol)
	{
		IEnumerable<string> parameters = methodSymbol.Parameters.Select(p => $"{p.Type} {p.Name}");
		return $"{methodSymbol.ReturnType} {methodSymbol.Name}({string.Join(", ", parameters)})";
	}

	/// <summary>
	/// Generates an XML documentation comment that inherits documentation from the specified target method.
	/// </summary>
	/// <param name="request">The abstraction request containing the target type information for documentation inheritance.</param>
	/// <param name="methodSymbol">The symbol representing the method for which the documentation comment is generated.</param>
	/// <returns>
	/// A string containing the XML documentation comment that references the target method using <c>&lt;inheritdoc&gt;</c>.
	/// </returns>
	private static string CreateMethodComment(AbstractionRequest request, IMethodSymbol methodSymbol)
	{
		IEnumerable<string> parameters = methodSymbol.Parameters.Select(p => $"{p.Type}".Replace('<', '{').Replace('>', '}'));
		return $"/// <inheritdoc cref=\"{request.TargetType}.{methodSymbol.Name}({string.Join(", ", parameters)})\"/>";
	}

	/// <summary>
	/// Retrieves the fully qualified namespace of the specified type symbol.
	/// </summary>
	/// <remarks>
	/// This method excludes the global namespace from the result. Use this method to obtain
	/// the complete namespace path for code generation or analysis scenarios.
	/// </remarks>
	/// <param name="symbol">
	/// The <see cref="INamedTypeSymbol"/> representing the type whose namespace is to be obtained.
	/// </param>
	/// <returns>
	/// A string containing the full namespace of the type, with segments separated by periods.
	/// Returns an empty string if the type is declared in the global namespace.
	/// </returns>
	private static string GetFullNamespace(INamedTypeSymbol symbol)
	{
		var ns = symbol.ContainingNamespace;
		if (ns == null || ns.IsGlobalNamespace)
			return string.Empty;

		var parts = new List<string>();
		while (ns != null && !ns.IsGlobalNamespace)
		{
			parts.Insert(0, ns.Name);
			ns = ns.ContainingNamespace;
		}
		return string.Join(".", parts);
	}

	/// <summary>
	/// Creates an <see cref="AbstractionRequest"/> from the given syntax context if the class
	/// is decorated with the <see cref="GenerateAbstractionAttribute"/>.
	/// </summary>
	/// <param name="ctx">The syntax context.</param>
	/// <param name="ct">The cancellation token.</param>
	/// <returns>
	/// An <see cref="AbstractionRequest"/> if the class has the <see cref="GenerateAbstractionAttribute"/>;
	/// otherwise, <see langword="null"/>.
	/// </returns>
	private static AbstractionRequest? CreateAbstractionRequest(GeneratorSyntaxContext ctx, CancellationToken ct)
	{
		ClassDeclarationSyntax classDeclaration = (ClassDeclarationSyntax)ctx.Node;
		ISymbol? classSymbol = ctx.SemanticModel.GetDeclaredSymbol(classDeclaration, ct);
		if (classSymbol == null)
			return null;

		foreach (AttributeData attributeData in classSymbol.GetAttributes())
		{
			if (attributeData.AttributeClass?.ToDisplayString() == GenerateAbstractionAttributeQualifiedName)
			{
				// Extract constructor arguments
				TypedConstant targetTypeArg = attributeData.ConstructorArguments[0];
				TypedConstant abstractionTypeArg = attributeData.ConstructorArguments[1];
				TypedConstant implementationTypeArg = attributeData.ConstructorArguments[2];
				TypedConstant excludeMethodsArg = attributeData.ConstructorArguments.Length > 3
					? attributeData.ConstructorArguments[3]
					: default;

				string[] excludeMethods = [];
				if (excludeMethodsArg.Kind is TypedConstantKind.Array)
					excludeMethods = [.. excludeMethodsArg.Values.Select(v => v.Value as string ?? string.Empty)];

				if (targetTypeArg.Value is INamedTypeSymbol targetType
					&& abstractionTypeArg.Value is INamedTypeSymbol abstractionType
					&& implementationTypeArg.Value is INamedTypeSymbol implementationType)
					return new AbstractionRequest(
						TargetType: targetType,
						AbstractionType: abstractionType,
						ImplementationType: implementationType,
						ExcludeMethods: excludeMethods
						);
			}
		}
		return null;
	}

	/// <summary>
	/// Indicates whether the given syntax node is a candidate for a class with the GenerateAbstraction attribute.
	/// </summary>
	/// <param name="node">The syntax node to check.</param>
	/// <returns>
	/// True if the node is a class declaration with the GenerateAbstraction attribute;
	/// otherwise, false.
	/// </returns>
	private static bool IsCandidateClassNode(SyntaxNode node)
		=> node is ClassDeclarationSyntax classDeclaration && classDeclaration.AttributeLists.Count > 0;
}
