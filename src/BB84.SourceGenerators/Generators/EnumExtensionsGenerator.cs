// Copyright: 2025 Robert Peter Meyer
// License: MIT
//
// This source code is licensed under the MIT license found in the
// LICENSE file in the root directory of this source tree.
using System.Text;

using BB84.SourceGenerators.Attributes;
using BB84.SourceGenerators.Extensions;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace BB84.SourceGenerators.Generators;

/// <summary>
/// Responsible for generating enumeratior extensions for enumeratiors marked
/// with the <see cref="GenerateEnumExtensionsAttribute"/> attribute.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class EnumExtensionsGenerator : IIncrementalGenerator
{
	private const string AttributeName = "GenerateEnumExtensions";

	/// <inheritdoc/>
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		IncrementalValuesProvider<EnumDeclarationSyntax> provider = context.SyntaxProvider.CreateSyntaxProvider(
			predicate: (node, _) =>
			{
				bool result = node is EnumDeclarationSyntax enumDeclaration
					&& enumDeclaration.AttributeLists.Count > 0
					&& enumDeclaration.AttributeLists.Any(attributeList
						=> attributeList.Attributes.Any(attribute
							=> attribute.Name.ToString() == AttributeName));

				return result;
			},
			transform: (context, _) =>
			{
				EnumDeclarationSyntax enumDeclaration = (EnumDeclarationSyntax)context.Node;
				return enumDeclaration;
			});

		context.RegisterSourceOutput(provider, (context, classDeclaration)
			=> Execute(classDeclaration, context));
	}

	private static void Execute(EnumDeclarationSyntax enumDeclaration, SourceProductionContext context)
	{
		List<EnumMemberDeclarationSyntax> members = [.. enumDeclaration.Members
			.OfType<EnumMemberDeclarationSyntax>()
			.Where(field => field is not null)];

		// fetch the field name and declaration type
		string enumName = enumDeclaration.Identifier.Text;
		string enumNamespace = enumDeclaration.GetNamespace();

		StringBuilder sourceBuilder = new();
		sourceBuilder.AppendAutoGeneratedWarning();
		sourceBuilder.AppendLine();

		sourceBuilder.AppendLine($"namespace {enumNamespace};");
		sourceBuilder.AppendLine("{");
		sourceBuilder.AppendLine("  /// <summary>");
		sourceBuilder.AppendLine($"  /// The <see cref=\"{enumName}Extensions\"/> class provides extension methods for the <see cref=\"{enumName}\"/> enumeration.");
		sourceBuilder.AppendLine("  /// </summary>");
		sourceBuilder.AppendLine($"  public static class {enumName}Extensions");
		sourceBuilder.AppendLine("  {");
		sourceBuilder.AppendLine("    /// <summary>");
		sourceBuilder.AppendLine("    /// Returns the name of the enumeration <paramref name=\"value\"/> as a string.");
		sourceBuilder.AppendLine("    /// </summary>");
		sourceBuilder.AppendLine("    /// <param name=\"value\">The enumeration value to convert to a string.</param>");
		sourceBuilder.AppendLine("    /// <returns>The name of the enumeration value as a string.</returns>");
		sourceBuilder.AppendLine($"    public static string ToStringFast(this {enumName} value)");
		sourceBuilder.AppendLine("    {");
		sourceBuilder.AppendLine("      return value switch");
		sourceBuilder.AppendLine("      {");
		foreach (EnumMemberDeclarationSyntax member in members)
		{
			string memberName = member.Identifier.Text;
			string memberValue = member.EqualsValue?.Value.ToString() ?? "0";
			sourceBuilder.AppendLine($"        {enumName}.{memberName} => nameof({enumName}.{memberName}),");
		}
		sourceBuilder.AppendLine("        _ => value.ToString(CultureInfo.InvariantCulture)");
		sourceBuilder.AppendLine("      };");
		sourceBuilder.AppendLine("    }");
		sourceBuilder.AppendLine();
		sourceBuilder.AppendLine($"    public static bool IsDefined({enumName} value)");
		sourceBuilder.AppendLine("    {");
		sourceBuilder.AppendLine("      return value switch");
		sourceBuilder.AppendLine("      {");
		foreach (EnumMemberDeclarationSyntax member in members)
		{
			string memberName = member.Identifier.Text;
			sourceBuilder.AppendLine($"        {enumName}.{memberName} => true,");
		}
		sourceBuilder.AppendLine("        _ => false");
		sourceBuilder.AppendLine("      };");
		sourceBuilder.AppendLine("    }");
		sourceBuilder.AppendLine();
		sourceBuilder.AppendLine($"    public static bool IsDefined(string name)");
		sourceBuilder.AppendLine("    {");
		sourceBuilder.AppendLine("      return name switch");
		sourceBuilder.AppendLine("      {");
		foreach (EnumMemberDeclarationSyntax member in members)
		{
			string memberName = member.Identifier.Text;
			sourceBuilder.AppendLine($"        nameof({enumName}.{memberName}) => true,");
		}
		sourceBuilder.AppendLine("        _ => false");
		sourceBuilder.AppendLine("      };");
		sourceBuilder.AppendLine("    }");
		sourceBuilder.AppendLine();
		sourceBuilder.AppendLine($"    public static {enumName}[] GetValues(this {enumName} value)");
		sourceBuilder.AppendLine("    {");
		sourceBuilder.AppendLine("      return new[]");
		sourceBuilder.AppendLine("      {");
		foreach (EnumMemberDeclarationSyntax member in members)
		{
			string memberName = member.Identifier.Text;
			sourceBuilder.AppendLine($"        {enumName}.{memberName},");
		}
		sourceBuilder.AppendLine("      };");
		sourceBuilder.AppendLine("    }");
		sourceBuilder.AppendLine();
		sourceBuilder.AppendLine($"    public static string[] GetNames(this {enumName} value)");
		sourceBuilder.AppendLine("    {");
		sourceBuilder.AppendLine("      return new[]");
		sourceBuilder.AppendLine("      {");
		foreach (EnumMemberDeclarationSyntax member in members)
		{
			string memberName = member.Identifier.Text;
			sourceBuilder.AppendLine($"        nameof({enumName}.{memberName}),");
		}
		sourceBuilder.AppendLine("      };");
		sourceBuilder.AppendLine("    }");
		sourceBuilder.AppendLine("  }");
		sourceBuilder.AppendLine("}");
		sourceBuilder.AppendLine();

		string sourceText = sourceBuilder.ToString();
		context.AddSource($"{enumName}.g.cs", sourceText);
	}
}
